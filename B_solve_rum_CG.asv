function [lambda_full, V_sub, subset_idx, rankings, choice_sets_out, error_val, iter, x_est] = ...
    solve_rum_columngen3(p_obs, n, init_k, max_iters, tol, choice_sets, pricing_mode, chosen_alts)
% SOLVE_RUM_COLUMNGEN3
% -------------------------------------------------------------------------
% Column generation solver for discrete choice RUM problem.
%  Added 'randominsertion' pricing mode 
% 
% Inputs:
%   p_obs        : observed choice probabilities (vector)
%   n            : number of alternatives
%   init_k       : number of initial columns (rankings) to start with
%   max_iters    : maximum number of iterations
%   tol          : convergence tolerance
%   choice_sets  : cell array of choice sets to use (if empty, generates all)
%   pricing_mode : 'brute', 'bestinsertion', or 'randominsertion' (default: 'brute')
%   chosen_alts  : vector of actually chosen alternatives for each observation (optional)
%
% Outputs:
%   lambda_full  : weights on selected columns (sums to 1)
%   V_sub        : matrix of selected choice vectors
%   subset_idx   : indices of selected rankings
%   rankings     : the actual selected rankings (matrix)
%   choice_sets_out : choice sets used in the algorithm
%   error_val    : final squared error
%   iter         : number of iterations performed
%   x_est        : estimated utilities (if computed)
% -------------------------------------------------------------------------

% Handle optional inputs
if nargin < 8 || isempty(chosen_alts)
    error('Error! Need chosen_alts');
end
if nargin < 7
    pricing_mode = 'brute';
end
if nargin < 6 || isempty(choice_sets)
    choice_sets = [];
end

fprintf('Starting column generation with %d initial columns...\n', init_k);
fprintf('Pricing mode: %s\n', pricing_mode);

% -------------------------------------------------------------------------
% Step 1: Only generate full rankings for brute force
% -------------------------------------------------------------------------

[V_full, all_rankings, choice_sets]=C_gen_V_full(n,choice_sets,pricing_mode,p_obs,chosen_alts);

% -------------------------------------------------------------------------
% INITIALIZATION: Start with init_k random rankings
% -------------------------------------------------------------------------

[V_sub, rankings, subset_idx] = C_gen_random_V(p_obs,init_k,choice_sets,chosen_alts,n);

% -------------------------------------------------------------------------
% COLUMN GENERATION MAIN LOOP
% -------------------------------------------------------------------------

prev_error = inf;

for iter = 1:max_iters
    
    % --- Solve Restricted Master Problem (RMP) ---
    % min ||V_sub * lambda - p_obs||^2
    % s.t. lambda >= 0, sum(lambda) = 1
    
    result=B_QP(V_sub,p_obs,false);
    error_val=result.QP.error;
    error_improvement = prev_error-error_val;
    % --- Pricing Problem: Find best new column to add ---
    
    if strcmp(pricing_mode, 'brute')
        % ===================================================================
        % BRUTE FORCE PRICING
        % ===================================================================
        [V_sub,subset_idx,rankings,best_score]=B_CG_exact(V_full,result.QP.residual,subset_idx,p_optim)

        scores = V_full' * result.QP.residual;
        scores(subset_idx) = -Inf;
        [best_score, best_idx] = max(scores);
        best_score = best_score-result.QP.optim_p' * result.QP.residual;
    elseif strcmp(pricing_mode, 'bestinsertion')
        % ===================================================================
        % BEST INSERTION PRICING (Greedy heuristic)
        % ===================================================================
        
        % Start with random alternative (ensure it's a row vector)
        best_ranking = randsample(n, 1);
        best_ranking = reshape(best_ranking, 1, []);  % Force row vector
        remaining_alts = setdiff(1:n, best_ranking);
        
        % Greedily add remaining alternatives
        while ~isempty(remaining_alts)
            best_pos = -1;
            best_pos_score = -Inf;
            best_alt_to_add = -1;
            
            % Try EACH remaining alternative
            for alt = remaining_alts
                % Try inserting at each position
                for pos = 1:(length(best_ranking) + 1)
                    % Create candidate ranking (handle different cases explicitly)
                    if pos == 1
                        candidate = [alt, best_ranking];
                    elseif pos > length(best_ranking)
                        candidate = [best_ranking, alt];
                    else
                        candidate = [best_ranking(1:pos-1), alt, best_ranking(pos:end)];
                    end
                    
                    % Compute score for this candidate
                    v_candidate = zeros(length(p_obs), 1);
                    for s = 1:length(choice_sets)
                        set_alts = choice_sets{s};
                        
                        % Skip if any alternative in this choice set is not yet in candidate
                        all_present = true;
                        for j = 1:length(set_alts)
                            if isempty(find(candidate == set_alts(j), 1))
                                all_present = false;
                                break;
                            end
                        end
                        if ~all_present
                            continue;  % Skip this choice set
                        end
                        
                        % Find positions of each alternative in the candidate ranking
    
                            % Where is {1,4,5} location in ranking [ 3 1 5 2 4]
                        positions = zeros(1, length(set_alts));
                        for j = 1:length(set_alts)
                            positions(j) = find(candidate == set_alts(j), 1, 'first');
                        end
                        
                        [~, top_idx] = min(positions);
                        top_alt = set_alts(top_idx);
                        
                        % Use chosen_alts if provided, otherwise default to set_alts(1)
                        if ~isempty(chosen_alts)
                            v_candidate(s) = (top_alt == chosen_alts(s));
                        else
                            v_candidate(s) = (top_alt == set_alts(1));
                        end
                    end
                    score = v_candidate' * residual;
                    
                    if score > best_pos_score
                        best_pos_score = score;
                        best_pos = pos;
                        best_alt_to_add = alt;
                    end
                end
            end
            
            % Insert best alternative at best position (handle cases explicitly)
            if best_pos == 1
                best_ranking = [best_alt_to_add, best_ranking];
            elseif best_pos > length(best_ranking)
                best_ranking = [best_ranking, best_alt_to_add];
            else
                best_ranking = [best_ranking(1:best_pos-1), best_alt_to_add, best_ranking(best_pos:end)];
            end
            
            remaining_alts = setdiff(remaining_alts, best_alt_to_add);
        end
        
        % Compute final score
        v_final = zeros(length(p_obs), 1);
        for s = 1:length(choice_sets)
            set_alts = choice_sets{s};
            
            % Find positions of each alternative in best_ranking
            positions = zeros(1, length(set_alts));
            for j = 1:length(set_alts)
                positions(j) = find(best_ranking == set_alts(j), 1, 'first');
            end
            
            [~, top_idx] = min(positions);
            top_alt = set_alts(top_idx);
            
            % Use chosen_alts if provided, otherwise default to set_alts(1)
            if ~isempty(chosen_alts)
                v_final(s) = (top_alt == chosen_alts(s));
            else
                v_final(s) = (top_alt == set_alts(1));
            end
        end
        best_score = v_final' * residual;
        
        best_idx = -1;
        
    else  % 'randominsertion'
        % ===================================================================
        % RANDOM INSERTION PRICING (Heuristic 1 from paper)
        % ===================================================================
        
        % Start with random alternative (ensure it's a row vector)
        best_ranking = randsample(n, 1);
        best_ranking = reshape(best_ranking, 1, []);  % Force row vector
        remaining_alts = setdiff(1:n, best_ranking);
        
        % Randomly add remaining alternatives
        while ~isempty(remaining_alts)
            % Pick ONE random alternative
            alt = randsample(remaining_alts, 1);
            
            best_pos = -1;
            best_pos_score = -Inf;
            
            % Try inserting ONLY this alternative at each position
            for pos = 1:(length(best_ranking) + 1)
                % Create candidate ranking (handle different cases explicitly)
                if pos == 1
                    candidate = [alt, best_ranking];
                elseif pos > length(best_ranking)
                    candidate = [best_ranking, alt];
                else
                    candidate = [best_ranking(1:pos-1), alt, best_ranking(pos:end)];
                end
                
                % Compute score for this candidate
                v_candidate = zeros(length(p_obs), 1);
                for s = 1:length(choice_sets)
                    set_alts = choice_sets{s};
                    
                    % Skip if any alternative in this choice set is not yet in candidate
                    all_present = true;
                    for j = 1:length(set_alts)
                        if isempty(find(candidate == set_alts(j), 1))
                            all_present = false;
                            break;
                        end
                    end
                    if ~all_present
                        continue;  % Skip this choice set
                    end
                    
                    % Find positions of each alternative in the candidate ranking
                    positions = zeros(1, length(set_alts));
                    for j = 1:length(set_alts)
                        positions(j) = find(candidate == set_alts(j), 1, 'first');
                    end
                    
                    [~, top_idx] = min(positions);
                    top_alt = set_alts(top_idx);
                    
                    % Use chosen_alts if provided, otherwise default to set_alts(1)
                    if ~isempty(chosen_alts)
                        v_candidate(s) = (top_alt == chosen_alts(s));
                    else
                        v_candidate(s) = (top_alt == set_alts(1));
                    end
                end
                score = v_candidate' * residual;
                
                if score > best_pos_score
                    best_pos_score = score;
                    best_pos = pos;
                end
            end
            
            % Insert this alternative at its best position (handle cases explicitly)
            if best_pos == 1
                best_ranking = [alt, best_ranking];
            elseif best_pos > length(best_ranking)
                best_ranking = [best_ranking, alt];
            else
                best_ranking = [best_ranking(1:best_pos-1), alt, best_ranking(best_pos:end)];
            end
            
            remaining_alts = setdiff(remaining_alts, alt);
        end
        
        % Compute final score
        v_final = zeros(length(p_obs), 1);
        for s = 1:length(choice_sets)
            set_alts = choice_sets{s};
            
            % Find positions of each alternative in best_ranking
            positions = zeros(1, length(set_alts));
            for j = 1:length(set_alts)
                positions(j) = find(best_ranking == set_alts(j), 1, 'first');
            end
            
            [~, top_idx] = min(positions);
            top_alt = set_alts(top_idx);
            
            % Use chosen_alts if provided, otherwise default to set_alts(1)
            if ~isempty(chosen_alts)
                v_final(s) = (top_alt == chosen_alts(s));
            else
                v_final(s) = (top_alt == set_alts(1));
            end
        end
        best_score = v_final' * residual;
        
        best_idx = -1;
    end
    
    % --- Check convergence ---
    
    fprintf('Iter %d | error = %.6f | best_score = %.4f | error_improvement = %.2e | ', ...
        iter, error_val, best_score, error_improvement);
    
    % Convergence condition: Error not improving significantly
    % ONLY for best insertion and random insertion modes (brute should run until best_score <= 0)
    if ~strcmp(pricing_mode, 'brute') && iter > 5 && error_improvement < 1e-12
        fprintf('new_col = -1 | subset_size = %d\n', length(subset_idx));
        fprintf('\nConverged! Error not improving (improvement = %.2e < 1e-12).\n', error_improvement);
        break;
    elseif strcmp(pricing_mode, 'brute') && best_score < tol
        fprintf('new_col = -1 | subset_size = %d\n', length(subset_idx));
        fprintf('\nConverged! Error not improving (improvement = %.2e < 1e-12).\n', error_improvement);
        break;
    end
    
    % Update previous error for next iteration
    prev_error = error_val;
    
    % --- Add new column ---
    
    if strcmp(pricing_mode, 'brute')
        % Brute mode: Add column from V_full
        V_sub = [V_sub, V_full(:, best_idx)];
        subset_idx = [subset_idx; best_idx];
        rankings = [rankings; all_rankings(best_idx, :)];
        fprintf('new_col = %d | subset_size = %d\n', best_idx, length(subset_idx));
    else
        % Best insertion or random insertion mode: Build column from constructed ranking
        v_new = zeros(length(p_obs), 1);
        for s = 1:length(choice_sets)
            set_alts = choice_sets{s};
            
            % Find positions of each alternative in best_ranking
            positions = zeros(1, length(set_alts));
            for j = 1:length(set_alts)
                positions(j) = find(best_ranking == set_alts(j), 1, 'first');
            end
            
            [~, top_idx] = min(positions);
            top_alt = set_alts(top_idx);
            
            % Use chosen_alts if provided, otherwise default to set_alts(1)
            if ~isempty(chosen_alts)
                v_new(s) = (top_alt == chosen_alts(s));
            else
                v_new(s) = (top_alt == set_alts(1));
            end
        end
        
        V_sub = [V_sub, v_new];
        best_ranking = reshape(best_ranking, 1, n);  % Ensure row vector with n elements
        rankings = [rankings; best_ranking];
        subset_idx = [subset_idx; length(subset_idx) + 1];
        fprintf('new_col = constructed | subset_size = %d\n', length(subset_idx));
    end
    
end

% -------------------------------------------------------------------------
% FINAL SOLVE: Recompute lambda with all selected columns
% -------------------------------------------------------------------------

H = 2 * (V_sub' * V_sub);
f = -2 * V_sub' * p_obs;
Aeq = ones(1, size(V_sub, 2));
beq = 1;
lb = zeros(size(V_sub, 2), 1);

options = optimoptions('quadprog', 'Display', 'off');
lambda_full = quadprog(H, f, [], [], Aeq, beq, lb, [], [], options);

error_val = norm(p_obs - V_sub * lambda_full)^2;

fprintf('\nFinal error = %.6f with %d columns selected (%d iterations).\n', ...
    error_val, length(subset_idx), iter);

% Return the choice sets used
choice_sets_out = choice_sets;

% Placeholder for x_est (utilities) - not computed in this version
x_est = [];

end
